using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ILOG.Concert;
using ILOG.CPLEX;
using Graphs;
using Matching;


namespace LP
{
    public class ProblemCPLEX : Problem
    {
        public int nbRows=0 ;
        public int nbCols=0;
        public int nbNzeros=0;
        int nbNode1;
        int nbNode2;
        int nbEdge1;
        int nbEdge2;
        bool copyEdge;

        public Cplex cplex;
        public ILPMatrix ilpMatrix;
        public double[] objCoef;

        public ProblemCPLEX(Graph g1, Graph g2)
        {
            this.graph1 = g1;
            this.graph2 = g2;
            exchange = false;
            nbNode1= g1.ListNodes.Count;
            nbNode2 = g2.ListNodes.Count;
            nbEdge1 = g1.ListEdges.Count;
            nbEdge2 = g2.ListEdges.Count;
            if (!g1.IsDirected) copyEdge = true;
            else copyEdge = false;
        }              
        public override void IsoSousGraphExactF1()
        {
            //rapport LeBodic P7
            Graph smallGraph, bigGraph;
            if ((this.graph1.ListNodes.Count() <= this.graph2.ListNodes.Count()) && (this.graph1.ListEdges.Count() <= this.graph2.ListEdges.Count()))
            {
                smallGraph = this.graph1;
                bigGraph = this.graph2;
                exchange = false;
            }
            else if ((this.graph1.ListNodes.Count() >= this.graph2.ListNodes.Count()) && (this.graph1.ListEdges.Count() >= this.graph2.ListEdges.Count()))
            {
                smallGraph = this.graph2;
                bigGraph = this.graph1;
                exchange = true;
                nbNode1 = smallGraph.ListNodes.Count;
                nbNode2 = bigGraph.ListNodes.Count;
                nbEdge1 = smallGraph.ListEdges.Count;
                nbEdge2 = bigGraph.ListEdges.Count;

            }
            else throw new System.Exception("can't be solved by F1");

            this.nbCols = nbNode1 * nbNode2 + nbEdge1 * nbEdge2;//nbvariables: nsng+msmg
            this.nbRows = nbNode1 + nbEdge1 + nbNode2 + 3* nbEdge1 * nbEdge2;//ns + ms+ng+3msmg contraintes
            
            #region objectFunction
            List<double> objList = new List<double>();
            List<string> colNameList = new List<string>();
            List<char> typeList = new List<char>();
            List<Double> ubList = new List<Double>();
            //the objet funcion
            for (int i = 1; i <= nbNode1; i++)
            {
                for (int k = 1; k <= nbNode2; k++)
                {
                    double coef = smallGraph.ListNodes[i - 1].Label.dissimilarity(bigGraph.ListNodes[k - 1].Label);
                    objList.Add(coef);
                    colNameList.Add("x_" + smallGraph.ListNodes[i - 1].Id + "," + bigGraph.ListNodes[k - 1].Id);
                }
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
                for (int kl = 1; kl <= nbEdge2; kl++)
                {
                    double costEdge = smallGraph.ListEdges[ij - 1].Label.dissimilarity(bigGraph.ListEdges[kl - 1].Label);
                    if (copyEdge)
                        objList.Add(costEdge / 2);
                    else objList.Add(costEdge);
                    colNameList.Add("y_" + smallGraph.ListEdges[ij - 1].Id + "," + bigGraph.ListEdges[kl - 1].Id);
                }
            #endregion

            try
            {
                cplex = new Cplex();
                ilpMatrix = cplex.AddLPMatrix();
                // add empty corresponding to new variables columns to ilpMatrix
                INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Bool, colNameList.ToArray());

                List<Double> lbMatrixList = new List<Double>();
                List<Double> ubMatrixList = new List<Double>();
                Int32[][] indiceH = new Int32[nbRows][];
                Double[][] valeurH = new Double[nbRows][];
                List<Int32> jaList;//les indice des valeurs
                List<Double> arList;//les valeurs non zeros dans la ligne

                int rownum = 0;
                #region construir constraintes
                /////// contraint: equation 2
                for (int i = 0; i <nbNode1; i++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int k = 0; k <nbNode2; k++)
                    {
                        jaList.Add(i * nbNode2 + k);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 3
                for (int ij = 0; ij < nbEdge1; ij++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij* nbEdge2 + kl);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //equation 4 
                for (int k = 0; k <nbNode2; k++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(0.0);
                    ubMatrixList.Add(1.0);
                    for (int i = 0; i <nbNode1; i++)
                    {
                        jaList.Add(nbNode2 *i + k);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //equation 5 6 7

                for (int ij = 0; ij < nbEdge1; ij++)
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        string source_i = smallGraph.ListEdges[ij].NodeSource.Id;
                        string source_k = bigGraph.ListEdges[kl].NodeSource.Id;
                        string target_i = smallGraph.ListEdges[ij].NodeTarget.Id;
                        string target_k = bigGraph.ListEdges[kl].NodeTarget.Id;

                        string nameVar = "x_" + source_i + "," + source_k;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();

                        string nameVar2 = "x_" + target_i + "," + target_k;
                        int colInd2 = SolverCPLEX.GetIndexByName(x, nameVar2);
                        if (colInd2 == -1)
                            throw new InvalidProgramException();

                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);
                        jaList.Add(colInd);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                        /////////////////////
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);
                        jaList.Add(colInd2);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                        //////////////////////// 
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(1.0);
                        jaList.Add(colInd);
                        arList.Add(1);
                        jaList.Add(colInd2);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

                #endregion
                Int32 res = ilpMatrix.AddRows(lbMatrixList.ToArray(), ubMatrixList.ToArray(), indiceH, valeurH);

                // add the objective function
                objCoef = objList.ToArray();
                cplex.AddMinimize(cplex.ScalProd(x, objCoef));
            }
            catch (ILOG.Concert.Exception e)
            {
                System.Console.WriteLine("Concert exception '" + e + "' caught");
            }
        }
        public override void IsoSousGraphExactF2()
        {
            Graph smallGraph, bigGraph;
            if ((this.graph1.ListNodes.Count() <= this.graph2.ListNodes.Count()) && (this.graph1.ListEdges.Count() <= this.graph2.ListEdges.Count()))
            {
                smallGraph = this.graph1;
                bigGraph = this.graph2;
                exchange = false;
            }
            else if ((this.graph1.ListNodes.Count() >= this.graph2.ListNodes.Count()) && (this.graph1.ListEdges.Count() >= this.graph2.ListEdges.Count()))
            {
                smallGraph = this.graph2;
                bigGraph = this.graph1;
                exchange = true;
                nbNode1 = smallGraph.ListNodes.Count;
                nbNode2 = bigGraph.ListNodes.Count;
                nbEdge1 = smallGraph.ListEdges.Count;
                nbEdge2 = bigGraph.ListEdges.Count;

            }
            else throw new System.Exception("can't be solved by F2");

            this.nbCols = nbNode1 * nbNode2 + nbEdge1 * nbEdge2;//nsng+msmg variables 
            this.nbRows = nbNode1 + nbEdge1 + nbNode2 + 2 * nbEdge1 * nbNode2;//ns + ms+ng+2ngms contraintes.

            #region objectFunction
            List<double> objList = new List<double>();
            List<string> colNameList = new List<string>();
            List<char> typeList = new List<char>();
            List<Double> ubList = new List<Double>();
            //the objet funcion
            for (int i = 1; i <= nbNode1; i++)
            {
                for (int k = 1; k <= nbNode2; k++)
                {
                    objList.Add(smallGraph.ListNodes[i - 1].Label.dissimilarity(bigGraph.ListNodes[k - 1].Label));
                    colNameList.Add("x_" + smallGraph.ListNodes[i - 1].Id + "," + bigGraph.ListNodes[k - 1].Id);
                }
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
                for (int kl = 1; kl <= nbEdge2; kl++)
                {
                    double costEdge = smallGraph.ListEdges[ij - 1].Label.dissimilarity(bigGraph.ListEdges[kl - 1].Label);
                    if (copyEdge)
                        objList.Add(costEdge / 2);
                    else objList.Add(costEdge);
                    colNameList.Add("y_" + smallGraph.ListEdges[ij - 1].Id + "," + bigGraph.ListEdges[kl - 1].Id);
                }
            #endregion

            try
            {
                cplex = new Cplex();
                ilpMatrix = cplex.AddLPMatrix();

                // add empty corresponding to new variables columns to ilpMatrix
                INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Bool, colNameList.ToArray());

                List<Double> lbMatrixList = new List<Double>();
                List<Double> ubMatrixList = new List<Double>();
                Int32[][] indiceH = new Int32[nbRows][];
                Double[][] valeurH = new Double[nbRows][];
                List<Int32> jaList;//les indice des valeurs
                List<Double> arList;//les valeurs non zeros dans la ligne

                int rownum = 0;
                #region construir constraintes
                /////// contraint: equation 2
                for (int i = 0; i < nbNode1; i++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int k = 0; k < nbNode2; k++)
                    {
                        jaList.Add(i * nbNode2 + k);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 3
                for (int ij = 0; ij < nbEdge1; ij++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int kl = 0; kl < nbEdge2; kl++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //equation 4 
                for (int k = 0; k < nbNode2; k++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(0.0);
                    ubMatrixList.Add(1.0);
                    for (int i = 0; i < nbNode1; i++)
                    {
                        jaList.Add(nbNode2 * i + k);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //equation 6 (If two vertices are matched together, 
                //an edge originating one of these two vertices must be matched with an edge originating the other vertex)
                for (int k = 0; k <nbNode2; k++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(0.0);
                        string source = smallGraph.ListEdges[ij].NodeSource.Id;
                        string nameVar = "x_" + source + "," + bigGraph.ListNodes[k].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();

                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = smallGraph.ListEdges[ij ].Id;
                        foreach (Edge e in bigGraph.ListNodes[k].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

                //equation 7 (If two vertices are matched together, 
                //an edge targeting one of these two vertices must be matched with an edge targeting the other vertex)
                for (int l = 0; l <nbNode2; l++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(0.0);
                        string target = smallGraph.ListEdges[ij].NodeTarget.Id;
                        string nameVar = "x_" + target + "," + bigGraph.ListNodes[l].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = smallGraph.ListEdges[ij].Id;
                        foreach (Edge e in bigGraph.ListNodes[l].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

                #endregion
                Int32 res = ilpMatrix.AddRows(lbMatrixList.ToArray(), ubMatrixList.ToArray(), indiceH, valeurH);

                // add the objective function
                objCoef = objList.ToArray();
                cplex.AddMinimize(cplex.ScalProd(x, objCoef));
            }
            catch (ILOG.Concert.Exception e)
            {
                System.Console.WriteLine("Concert exception '" + e + "' caught");
            }
            
        }
        public override void IsoSousGraphInexactF1a()
        {
            this.nbCols = nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1;//nsng+msmg+ns+ms variables, 
            this.nbRows = nbNode1 + nbEdge1 + nbNode2 + 3* nbEdge1 * nbEdge2;//ns + ms+ng+3msmg contraintes.
            exchange = false;
            Graphs.Label nodeepslabel;

            #region objectFunction
            List<double> objList = new List<double>();
            List<string> colNameList = new List<string>();
            List<char> typeList = new List<char>();
            List<Double> ubList = new List<Double>();
            //the objet funcion
            for (int i = 1; i <= nbNode1; i++)
            {
                for (int k = 1; k <= nbNode2; k++)
                {
                    objList.Add(graph1.ListNodes[i - 1].Label.dissimilarity(graph2.ListNodes[k - 1].Label));
                    colNameList.Add("x_" + graph1.ListNodes[i - 1].Id + "," + graph2.ListNodes[k - 1].Id);
                }
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
                for (int kl = 1; kl <= nbEdge2; kl++)
                {
                    double costEdge = graph1.ListEdges[ij - 1].Label.dissimilarity(graph2.ListEdges[kl - 1].Label);
                    if (copyEdge)
                        objList.Add(costEdge / 2);
                    else objList.Add(costEdge);
                    colNameList.Add("y_" + graph1.ListEdges[ij - 1].Id + "," + graph2.ListEdges[kl - 1].Id);
                }
            for (int i = 1; i <= nbNode1; i++)
            {
                Type typeLabel = graph1.ListNodes[i - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;

                objList.Add((graph1.ListNodes[i - 1].Label).dissimilarity(nodeepslabel));
                colNameList.Add("u_" + graph1.ListNodes[i - 1].Id + ",Ins_" + graph1.ListNodes[i - 1].Id);
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
            {
                Type typeLabel = graph1.ListEdges[ij - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                double costEdge = (graph1.ListEdges[ij - 1].Label).dissimilarity(nodeepslabel);
                if (copyEdge)
                    objList.Add(costEdge / 2);
                else objList.Add(costEdge);
                colNameList.Add("e_" + graph1.ListEdges[ij - 1].Id + ",Ins_" + graph1.ListEdges[ij - 1].Id);
            }
            #endregion

            try
            {
                cplex = new Cplex();
                ilpMatrix = cplex.AddLPMatrix();

                // add empty corresponding to new variables columns to ilpMatrix
                INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Bool, colNameList.ToArray());

                List<Double> lbMatrixList = new List<Double>();
                List<Double> ubMatrixList = new List<Double>();
                Int32[][] indiceH = new Int32[nbRows][];
                Double[][] valeurH = new Double[nbRows][];
                List<Int32> jaList;//les indice des valeurs
                List<Double> arList;//les valeurs non zeros dans la ligne

                int rownum = 0;
                #region construir constraintes
                // contraint: equation 19
                for (int i = 0; i <nbNode1; i++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int k = 0; k <nbNode2; k++)
                    {
                        jaList.Add(i* nbNode2 + k);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + i);
                    arList.Add(1);
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 20 
                for (int ij = 0; ij <nbEdge1; ij++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                    arList.Add(1);
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;

                }

                //equation 21 
                for (int k = 0; k <nbNode2; k++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(0.0);
                    ubMatrixList.Add(1.0);
                    for (int i = 0; i <nbNode1; i++)
                    {
                        jaList.Add(nbNode2 * i + k);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //equation 22 23 24

                for (int ij = 0; ij < nbEdge1; ij++)
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        string source_i = graph1.ListEdges[ij ].NodeSource.Id;
                        string source_k = graph2.ListEdges[kl].NodeSource.Id;
                        string target_i = graph1.ListEdges[ij].NodeTarget.Id;
                        string target_k = graph2.ListEdges[kl].NodeTarget.Id;

                        string nameVar = "x_" + source_i + "," + source_k;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();

                        string nameVar2 = "x_" + target_i + "," + target_k;
                        int colInd2 = SolverCPLEX.GetIndexByName(x, nameVar2);
                        if (colInd2== -1)
                            throw new InvalidProgramException();

                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);

                        jaList.Add(colInd);
                        arList.Add(1);
                        
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                        //////////////////////
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);
                        jaList.Add(colInd2);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                        ////////////
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(1.0);
                        jaList.Add(colInd);
                        arList.Add(1);
                        jaList.Add(colInd2);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 +ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    } 
                
                #endregion
                Int32 res = ilpMatrix.AddRows(lbMatrixList.ToArray(), ubMatrixList.ToArray(), indiceH, valeurH);

                // add the objective function
                objCoef = objList.ToArray();
                cplex.AddMinimize(cplex.ScalProd(x, objCoef));
            }
            catch (ILOG.Concert.Exception e)
            {
                System.Console.WriteLine("Concert exception '" + e + "' caught");
            }
        }
        public override void IsoSousGraphInexactF2a()
        {
            this.nbCols = nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1;//n1n2+m1m2+n1+m1 variables
            this.nbRows = nbNode1 + nbEdge1 + nbNode2 + 4 * nbEdge1 * nbNode2; //n1 + m1+n2+4n2m1 contraintes
            Graphs.Label nodeepslabel;
            exchange = false;

            #region objectFunction
            List<double> objList = new List<double>();
            List<string> colNameList = new List<string>();
            List<char> typeList = new List<char>();
            List<Double> ubList = new List<Double>();
            //the objet funcion
            for (int i = 1; i <= nbNode1; i++)
            {
                for (int k = 1; k <= nbNode2; k++)
                {
                    objList.Add(graph1.ListNodes[i - 1].Label.dissimilarity(graph2.ListNodes[k - 1].Label));
                    colNameList.Add("x_" + graph1.ListNodes[i - 1].Id + "," + graph2.ListNodes[k - 1].Id);
                }
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
                for (int kl = 1; kl <= nbEdge2; kl++)
                {
                    double costEdge = graph1.ListEdges[ij - 1].Label.dissimilarity(graph2.ListEdges[kl - 1].Label);
                    if (copyEdge)
                        objList.Add(costEdge / 2);
                    else objList.Add(costEdge);
                    colNameList.Add("y_" + graph1.ListEdges[ij - 1].Id + "," + graph2.ListEdges[kl - 1].Id);
                }
            for (int i = 1; i <= nbNode1; i++)
            {
                Type typeLabel = graph1.ListNodes[i - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;

                objList.Add((graph1.ListNodes[i - 1].Label).dissimilarity(nodeepslabel));
                colNameList.Add("u_" + graph1.ListNodes[i - 1].Id + ",Ins_" + graph1.ListNodes[i - 1].Id);
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
            {
                Type typeLabel = graph1.ListEdges[ij - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                double costEdge = (graph1.ListEdges[ij - 1].Label).dissimilarity(nodeepslabel);
                if (copyEdge)
                    objList.Add(costEdge / 2);
                else objList.Add(costEdge);
                colNameList.Add("e_" + graph1.ListEdges[ij - 1].Id + ",Ins_" + graph1.ListEdges[ij - 1].Id);
            }
            #endregion

            try
            {
                cplex = new Cplex();
                ilpMatrix = cplex.AddLPMatrix();

                // add empty corresponding to new variables columns to ilpMatrix
                INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Bool, colNameList.ToArray());

                List<Double> lbMatrixList = new List<Double>();
                List<Double> ubMatrixList = new List<Double>();
                Int32[][] indiceH = new Int32[nbRows][];
                Double[][] valeurH = new Double[nbRows][];
                List<Int32> jaList;//les indice des valeurs
                List<Double> arList;//les valeurs non zeros dans la ligne

                int rownum = 0;
                #region construir constraintes
                // contraint: equation 34
                for (int i = 0; i < nbNode1; i++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int k = 0; k <nbNode2; k++)
                    {
                        jaList.Add(i * nbNode2 + k);
                        arList.Add(1);
                    }
                    //u_i
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + i);
                    arList.Add(1);
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 35 
                for (int ij =0; ij < nbEdge1; ij++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int kl = 0; kl < nbEdge2; kl++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                    arList.Add(1);
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //equation 36
                for (int k = 0; k <nbNode2; k++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(0.0);
                    ubMatrixList.Add(1.0);
                    for (int i = 0; i < nbNode1; i++)
                    {
                        jaList.Add(nbNode2 * i + k);
                        arList.Add(1);
                    }
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                //38  If two vertices are matched together, 
                //an edge originating one of these two vertices must be matched with an edge originating the other vertex)
                for (int k = 0; k < nbNode2; k++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);


                        string source = graph1.ListEdges[ij].NodeSource.Id;
                        string nameVar = "x_" + source + "," + graph2.ListNodes[k].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[k].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

                //37  
               /* for (int k = 0; k <nbNode2; k++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(0.0);

                        string source = graph1.ListEdges[ij].NodeSource.Id;
                        string nameVar = "x_" + source + "," + graph2.ListNodes[k].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        nameVar = "u_" + source + ",Ins_" + source;
                        colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[k].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }*/

                //equation 40 (If two vertices are matched together, 
                //an edge targeting one of these two vertices must be matched with an edge targeting the other vertex)
                for (int l = 0; l < nbNode2; l++)
                    for (int ij = 0; ij < nbEdge1; ij++)
                    {
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);

                        string target = graph1.ListEdges[ij].NodeTarget.Id;
                        string nameVar = "x_" + target + "," + graph2.ListNodes[l].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[l].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

                //equation 39
               /* for (int l = 0; l < nbNode2; l++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(0.0);

                        string target = graph1.ListEdges[ij].NodeTarget.Id;
                        string nameVar = "x_" + target + "," + graph2.ListNodes[l].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        nameVar = "u_" + target + ",Ins_" + target;
                        colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[l].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);//SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                    }*/
                #endregion
                Int32 res = ilpMatrix.AddRows(lbMatrixList.ToArray(), ubMatrixList.ToArray(), indiceH, valeurH);

                // add the objective function
                objCoef = objList.ToArray();
                cplex.AddMinimize(cplex.ScalProd(x, objCoef));
            }
            catch (ILOG.Concert.Exception e)
            {
                System.Console.WriteLine("Concert exception '" + e + "' caught");
            }

            
           
        }
        public override void IsoGraphInexactF1b()
        {
            this.nbRows = nbNode1 + nbEdge1 + nbNode2 + nbEdge2 + 3 * nbEdge1 * nbEdge2; //ns + ms+ng+mg+3msmg
            this.nbCols = nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + nbNode2 + nbEdge2;//nsng+msmg+ns+ms+ng+mg
            Graphs.Label nodeepslabel;
         
            #region objectFunction
            List<double> objList = new List<double>();
            List<string> colNameList = new List<string>();
            List<char> typeList = new List<char>();
            List<Double> ubList = new List<Double>();
            //the objet funcion
            for (int i = 1; i <= nbNode1; i++)
            {
                for (int k = 1; k <= nbNode2; k++)
                {
                    objList.Add(graph1.ListNodes[i - 1].Label.dissimilarity(graph2.ListNodes[k - 1].Label));
                    colNameList.Add("x_" + graph1.ListNodes[i - 1].Id + "," + graph2.ListNodes[k - 1].Id);
                }
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
                for (int kl = 1; kl <= nbEdge2; kl++)
                {
                    double costEdge = graph1.ListEdges[ij - 1].Label.dissimilarity(graph2.ListEdges[kl - 1].Label);
                    if(copyEdge)
                        objList.Add(costEdge / 2);
                    else objList.Add(costEdge);
                    colNameList.Add("y_" + graph1.ListEdges[ij - 1].Id + "," + graph2.ListEdges[kl - 1].Id);
                }
            for (int i = 1; i <= nbNode1; i++)
            {
                Type typeLabel = graph1.ListNodes[i - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;               

                objList.Add((graph1.ListNodes[i - 1].Label).dissimilarity(nodeepslabel));
                colNameList.Add("u_" + graph1.ListNodes[i - 1].Id + ",Ins_" + graph1.ListNodes[i - 1].Id);
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
            {
                Type typeLabel = graph1.ListEdges[ij - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                double costEdge = (graph1.ListEdges[ij - 1].Label).dissimilarity(nodeepslabel);
                if(copyEdge)
                objList.Add(costEdge/2);
                else objList.Add(costEdge);
                colNameList.Add("e_" + graph1.ListEdges[ij - 1].Id + ",Ins_" + graph1.ListEdges[ij - 1].Id);
            }

            for (int k = 1; k <= nbNode2; k++)
            {
                Type typeLabel = graph2.ListNodes[k - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                objList.Add((graph2.ListNodes[k - 1].Label).dissimilarity(nodeepslabel));
                colNameList.Add("v_Del_" + graph2.ListNodes[k - 1].Id + "," + graph2.ListNodes[k - 1].Id);
            }

            for (int kl = 1; kl <= nbEdge2; kl++)
            {
                Type typeLabel = graph2.ListEdges[kl - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                double costEdge = (graph2.ListEdges[kl - 1].Label).dissimilarity(nodeepslabel);
                if(copyEdge)
                    objList.Add(costEdge / 2);
                else objList.Add(costEdge);
                colNameList.Add("f_Del_" + graph2.ListEdges[kl - 1].Id + "," + graph2.ListEdges[kl - 1].Id);
            }
           #endregion

           try
            {
                cplex = new Cplex();
                ilpMatrix = cplex.AddLPMatrix();

                // add empty corresponding to new variables columns to ilpMatrix
               INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Bool, colNameList.ToArray());
               
                List<Double> lbMatrixList = new List<Double>();
                List<Double> ubMatrixList = new List<Double>();
                Int32[][] indiceH = new Int32[nbRows][];
                Double[][] valeurH = new Double[nbRows][];
                List<Int32> jaList;//les indice des valeurs
                List<Double> arList;//les valeurs non zeros dans la ligne

                int rownum = 0;
                #region construir constraintes
                for (int i = 0; i < nbNode1; i++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int k = 0; k <nbNode2; k++)
                    {
                        
                        jaList.Add(i * nbNode2 + k);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + i);
                    arList.Add(1);
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 3 
                for (int ij = 0; ij < nbEdge1; ij++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                    arList.Add(1);

                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                // contraint: equation [Fb.1]-4
                for (int k = 0; k <nbNode2; k++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int i = 0; i <nbNode1; i++)
                    {
                        jaList.Add(i * nbNode2 + k);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + k);
                    arList.Add(1);
                    
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 5
                for (int kl = 0; kl < nbEdge2; kl++)
                {
                    jaList = new List<int>();//les indice des valeurs
                    arList = new List<Double>();//les valeurs non zeros dans la ligne
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                  
                    for (int ij = 0; ij < nbEdge1; ij++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + nbNode2 + kl);
                    arList.Add(1);

                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;

                }


                //equation 6 7 8
                for (int ij = 0; ij <nbEdge1; ij++)
                    for (int kl = 0; kl < nbEdge2; kl++)
                    {
                        string source_i = graph1.ListEdges[ij].NodeSource.Id;
                        string source_k = graph2.ListEdges[kl].NodeSource.Id;
                        string target_i = graph1.ListEdges[ij].NodeTarget.Id;
                        string target_k = graph2.ListEdges[kl].NodeTarget.Id;

                        string nameVar = "x_" + source_i + "," + source_k;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();

                        string nameVar2 = "x_" + target_i + "," + target_k;
                        int colInd2 = SolverCPLEX.GetIndexByName(x, nameVar2);
                        if (colInd2 == -1)
                            throw new InvalidProgramException();

                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);
                        jaList.Add(colInd);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                        ////////////////////////////////
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);
                        
                       
                        jaList.Add(colInd2);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(-1);

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                        ////////////////////////////////////////
                        jaList = new List<int>();
                        arList = new List<Double>();
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(1.0);
                        
                        jaList.Add(colInd);
                        arList.Add(1);
                        jaList.Add(colInd2);
                        arList.Add(1);
                        jaList.Add(nbNode1 * nbNode2 + ij* nbEdge2 + kl);
                        arList.Add(-1);

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }
                #endregion
                double[] lb = lbMatrixList.ToArray();
                double[] ub = ubMatrixList.ToArray();

                Int32 res = ilpMatrix.AddRows(lb, ub, indiceH, valeurH); 

                // add the objective function
                objCoef = objList.ToArray();
                cplex.AddMinimize(cplex.ScalProd(x, objCoef));
             }
            catch (ILOG.Concert.Exception e)
            {
                System.Console.WriteLine("Concert exception '" + e + "' caught");
            }
        }
        public override void IsoGraphInexactF2b()
        {
            this.nbRows = nbNode1 + nbEdge1 + nbNode2 + nbEdge2 + 4 * nbNode2 * nbEdge1 + 4 * nbNode1 * nbEdge2; //ns +ms+ng+mg+4ngms +4nsmg
            this.nbCols = nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + nbNode2 + nbEdge2;//nsng+msmg+ns+ms+ng+mg

             Graphs.Label nodeepslabel;
         
            #region objectFunction
            List<double> objList = new List<double>();
            List<string> colNameList = new List<string>();
            List<char> typeList = new List<char>();
            List<Double> ubList = new List<Double>();
            //the objet funcion
            for (int i = 1; i <= nbNode1; i++)
            {
                for (int k = 1; k <= nbNode2; k++)
                {
                    objList.Add(graph1.ListNodes[i - 1].Label.dissimilarity(graph2.ListNodes[k - 1].Label));
                    colNameList.Add("x_" + graph1.ListNodes[i - 1].Id + "," + graph2.ListNodes[k - 1].Id);
                }
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
                for (int kl = 1; kl <= nbEdge2; kl++)
                {
                    double costEdge = graph1.ListEdges[ij - 1].Label.dissimilarity(graph2.ListEdges[kl - 1].Label);
                    if (copyEdge)
                        objList.Add(costEdge / 2);
                    else objList.Add(costEdge);
                    colNameList.Add("y_" + graph1.ListEdges[ij - 1].Id + "," + graph2.ListEdges[kl - 1].Id);
                }
            for (int i = 1; i <= nbNode1; i++)
            {
                Type typeLabel = graph1.ListNodes[i - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;

                objList.Add((graph1.ListNodes[i - 1].Label).dissimilarity(nodeepslabel));
                colNameList.Add("u_" + graph1.ListNodes[i - 1].Id + ",Ins_" + graph1.ListNodes[i - 1].Id);
            }

            for (int ij = 1; ij <= nbEdge1; ij++)
            {
                Type typeLabel = graph1.ListEdges[ij - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                double costEdge = (graph1.ListEdges[ij - 1].Label).dissimilarity(nodeepslabel);
                if (copyEdge)
                    objList.Add(costEdge / 2);
                else objList.Add(costEdge);
                colNameList.Add("e_" + graph1.ListEdges[ij - 1].Id + ",Ins_" + graph1.ListEdges[ij - 1].Id);
            }

            for (int k = 1; k <= nbNode2; k++)
            {
                Type typeLabel = graph2.ListNodes[k - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                objList.Add((graph2.ListNodes[k - 1].Label).dissimilarity(nodeepslabel));
                colNameList.Add("v_Del_" + graph2.ListNodes[k - 1].Id + "," + graph2.ListNodes[k - 1].Id);
            }

            for (int kl = 1; kl <= nbEdge2; kl++)
            {
                Type typeLabel = graph2.ListEdges[kl - 1].Label.GetType();
                object obj = Activator.CreateInstance(typeLabel);
                nodeepslabel = (Graphs.Label)obj;
                nodeepslabel.Id = ConstantsAC.EPS_ID;
                double costEdge = (graph2.ListEdges[kl - 1].Label).dissimilarity(nodeepslabel);
                if (copyEdge)
                    objList.Add(costEdge / 2);
                else objList.Add(costEdge);
                colNameList.Add("f_Del_" + graph2.ListEdges[kl - 1].Id + "," + graph2.ListEdges[kl - 1].Id);
            }
           #endregion

           try
            {
                cplex = new Cplex();
                ilpMatrix = cplex.AddLPMatrix();

                // add empty corresponding to new variables columns to ilpMatrix
                INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Bool, colNameList.ToArray());
                //INumVar[] x = cplex.NumVarArray(cplex.ColumnArray(ilpMatrix, nbCols), 0, 1, NumVarType.Int, colNameList.ToArray());
               
                List<Double> lbMatrixList = new List<Double>();
                List<Double> ubMatrixList = new List<Double>();
                Int32[][] indiceH = new Int32[nbRows][];
                Double[][] valeurH = new Double[nbRows][];
                List<Int32> jaList;//les indice des valeurs
                List<Double> arList;//les valeurs non zeros dans la ligne

                int rownum = 0;
                #region construir constraintes
                for (int i = 0; i < nbNode1; i++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int k = 0; k < nbNode2; k++)
                    {

                        jaList.Add(i* nbNode2 + k);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + i);
                    arList.Add(1);
                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 3 
                for (int ij = 0; ij <nbEdge1; ij++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList.Add(nbNode1 * nbNode2 + ij * nbEdge2 + kl);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                    arList.Add(1);

                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }

                // contraint: equation [Fb.1]-4
                for (int k =0; k <nbNode2; k++)
                {
                    jaList = new List<int>();
                    arList = new List<Double>();
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);
                    for (int i = 0; i <nbNode1; i++)
                    {
                        jaList.Add(i * nbNode2 + k);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + k);
                    arList.Add(1);

                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;
                }


                // equation 5
                for (int kl = 0; kl < nbEdge2; kl++)
                {
                    jaList = new List<int>();//les indice des valeurs
                    arList = new List<Double>();//les valeurs non zeros dans la ligne
                    lbMatrixList.Add(1.0);
                    ubMatrixList.Add(1.0);

                    for (int ij = 0; ij < nbEdge1; ij++)
                    {
                        jaList.Add(nbNode1 * nbNode2 +ij* nbEdge2 + kl);
                        arList.Add(1);
                    }
                    jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + nbNode2 + kl);
                    arList.Add(1);

                    indiceH[rownum] = jaList.ToArray();
                    valeurH[rownum] = arList.ToArray();
                    rownum++;

                }


                //6 If two vertices are matched together, 
                //an edge originating one of these two vertices must be matched with an edge originating the other vertex)
                for (int k = 0; k <nbNode2; k++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);


                        string source = graph1.ListEdges[ij].NodeSource.Id;
                        string nameVar = "x_" + source + "," + graph2.ListNodes[k].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();

                        jaList.Add(colInd);
                        arList.Add(1);
                       

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[k].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

         /*       //7
                for (int k = 0; k <nbNode2; k++)
                    for (int ij = 0; ij <nbEdge1; ij++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(0.0);


                        string source = graph1.ListEdges[ij].NodeSource.Id;
                        string nameVar = "x_" + source + "," + graph2.ListNodes[k].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        nameVar = "u_" + source + ",Ins_" + source;
                        colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[k].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                        arList.Add(-1);

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }
          * */
                //equation 8 (If two vertices are matched together, 
                //an edge targeting one of these two vertices must be matched with an edge targeting the other vertex)
                for (int l = 0; l <nbNode2; l++)
                    for (int ij = 0; ij < nbEdge1; ij++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);

                        string target = graph1.ListEdges[ij].NodeTarget.Id;
                        string nameVar = "x_" + target + "," + graph2.ListNodes[l].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[l].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                    }

                //equation 9
           /*     for (int l = 0; l < nbNode2; l++)
                    for (int ij = 0; ij < nbEdge1; ij++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(0.0);

                        string target = graph1.ListEdges[ij].NodeTarget.Id;
                        string nameVar = "x_" + target + "," + graph2.ListNodes[l ].Id;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        nameVar = "u_" + target + ",Ins_" + target;
                        colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph1.ListEdges[ij].Id;
                        foreach (Edge e in graph2.ListNodes[l].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name1 + "," + name2;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + ij);
                        arList.Add(-1);

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                    }*/

                //10 If two vertices are matched together, 
                //an edge originating one of these two vertices must be matched with an edge originating the other vertex)
                for (int i = 0; i < nbNode1; i++)
                    for (int kl =0; kl <nbEdge2; kl++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);


                        string source = graph2.ListEdges[kl].NodeSource.Id;
                        string nameVar = "x_" + graph1.ListNodes[i].Id + "," + source;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph2.ListEdges[kl].Id;
                        foreach (Edge e in graph1.ListNodes[i].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name2 + "," + name1;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }

        /*        //11
                for (int i = 0; i <nbNode1; i++)
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(0.0);


                        string source = graph2.ListEdges[kl].NodeSource.Id;
                        string nameVar = "x_" + graph1.ListNodes[i].Id + "," + source;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        nameVar = "v_Del_" + source + "," + source;
                        colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph2.ListEdges[kl].Id;
                        foreach (Edge e in graph1.ListNodes[i].ListEdgesOut)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name2 + "," + name1;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + nbNode2 + kl);
                        arList.Add(-1);

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;
                    }*/

                //equation 12 (If two vertices are matched together, 
                //an edge targeting one of these two vertices must be matched with an edge targeting the other vertex)
                for (int j = 0; j < nbNode1; j++)
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(0.0);
                        ubMatrixList.Add(1.0);

                        string target = graph2.ListEdges[kl].NodeTarget.Id;
                        string nameVar = "x_" + graph1.ListNodes[j].Id + "," + target;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph2.ListEdges[kl].Id;
                        foreach (Edge e in graph1.ListNodes[j].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name2 + "," + name1;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                    }

          /*     //equation 13
                for (int j = 0; j < nbNode1; j++)
                    for (int kl = 0; kl <nbEdge2; kl++)
                    {
                        jaList = new List<int>();//les indice des valeurs
                        arList = new List<Double>();//les valeurs non zeros dans la ligne
                        lbMatrixList.Add(-1.0);
                        ubMatrixList.Add(0.0);

                        string target = graph2.ListEdges[kl].NodeTarget.Id;
                        string nameVar = "x_" + graph1.ListNodes[j].Id + "," + target;
                        int colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        nameVar = "v_Del_" + target + "," + target;
                        colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                        if (colInd == -1)
                            throw new InvalidProgramException();
                        jaList.Add(colInd);
                        arList.Add(1);

                        string name1 = graph2.ListEdges[kl].Id;
                        foreach (Edge e in graph1.ListNodes[j].ListEdgesIn)
                        {
                            string name2 = e.Id;
                            nameVar = "y_" + name2 + "," + name1;
                            colInd = SolverCPLEX.GetIndexByName(x, nameVar);
                            if (colInd == -1)
                                throw new InvalidProgramException();
                            jaList.Add(colInd);
                            arList.Add(-1);
                        }
                        jaList.Add(nbNode1 * nbNode2 + nbEdge1 * nbEdge2 + nbNode1 + nbEdge1 + nbNode2 + kl);
                        arList.Add(-1);

                        indiceH[rownum] = jaList.ToArray();
                        valeurH[rownum] = arList.ToArray();
                        rownum++;

                    }*/
                #endregion
                Int32 res = ilpMatrix.AddRows(lbMatrixList.ToArray(), ubMatrixList.ToArray(), indiceH, valeurH);

                // add the objective function
                objCoef = objList.ToArray();
                cplex.AddMinimize(cplex.ScalProd(x, objCoef));
            }
           catch (ILOG.Concert.Exception e)
           {
               System.Console.WriteLine("Concert exception '" + e + "' caught");
           }
        }
    }
}
